lab2@lab2-OptiPlex-3040:~/Desktop/Assignment 1_2/Assignment 1/bomb001$ sudo nano phase1.txt
[sudo] password for lab2: 
lab2@lab2-OptiPlex-3040:~/Desktop/Assignment 1_2/Assignment 1/bomb001$ ls
ans1.txt  bomb  bomb-assembly.s  bomb.c  bomblab.pdf  phase1.txt
lab2@lab2-OptiPlex-3040:~/Desktop/Assignment 1_2/Assignment 1/bomb001$ gdb bomb
GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from bomb...
(gdb) b phase_2
Breakpoint 1 at 0x400ea9
(gdb) run ans1.txt
Starting program: /home/lab2/Desktop/Assignment 1_2/Assignment 1/bomb001/bomb ans1.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>            //From this function the user can know that there are six digits. 
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)			      //Checks weather the first digit of the system is greater than first input number or not.   
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>		      //Jumps to line number 43 if not equal.
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)			      
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>  	      //The bomb explodes if the first digit is not equal compared to first input. 
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)			       //Comparison of input digit and the digit of phase 2.
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx			       //We are comparing something here! 
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u* 0x0000000000400ec2						       //To execute until the line 0x0000000000400ec2
0x0000000000400ec2 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
=> 0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>		//Shows that the compiler has executed until 0x0000000000400ec2
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) ni									//Proceeds to next line of the code.
0x0000000000400ec7 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
=> 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)				//Comparing 0 and register rsp value.
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>			//Jump if $0x0 and ($rsp) are not equal.
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)				//Comparing 1 and rsp value.
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>			//Jump to line number 48 if $0x1 and 0x4(%rsp) are equal.
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)				//Comparing %eax and 0x8(%rbx) value.
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>			//Jump to line number 71 if $eax and 0x8(%rbx) valueare equal. 
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx				//Comparing values.
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>			//Jumps to line number 56 if %rbp and %rbx is not equal.
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) x/d 0x0    //mistake
0x0:	Cannot access memory at address 0x0 	//mistake
(gdb) i r							//Details of Information Register.
rax            0x6                 6
rbx            0x7fffffffdef8      140737488346872
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x0                 0x0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ec7            0x400ec7 <phase_2+30>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) x/d 0x7fffffffddc0						//Figure out rsp value
0x7fffffffddc0:	1
(gdb) run ans1.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y					//Run the compiler again.
Starting program: /home/lab2/Desktop/Assignment 1_2/Assignment 1/bomb001/bomb ans1.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 1 2 3 4 5								//Input the values again with first traced digits as 0.				

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u*0x0000000000400ec7						//Execute until the line 0x0000000000400ec7.
0x0000000000400ec7 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
=> 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x6                 6
rbx            0x7fffffffdef8      140737488346872
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x0                 0x0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ec7            0x400ec7 <phase_2+30>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) x/d 0x7fffffffddc0
0x7fffffffddc0:	0				//Now the bomb dosen't blown up since the first input digit "0" matches the digit of phase 2.
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
=> 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)				//Compare the value of $0x0 and (%rsp).	
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u*   0x0000000000400ecd							//Execute until 0x0000000000400ecd.
0x0000000000400ecd in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
=> 0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)				//Compiler reaches to 0x0000000000400ecd. Compares the value of %0x1 and 0x4(%rsp).
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>			//Jumps to line number to 48 if two numbers is equal.
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x6                 6
rbx            0x7fffffffdef8      140737488346872
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x0                 0x0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ecd            0x400ecd <phase_2+36>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) x/2d 0x7fffffffddc0				// Find out the value of second input digit.
0x7fffffffddc0:	0	1
(gdb) u* 0x0000000000400ed9
0x0000000000400ed9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)			//Since the value of %0x1 and 0x4(%rsp) matches then it moves to line number 48.
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
=> 0x0000000000400ed9 <+48>:	mov    %rsp,%rbx			//Move the value of %rbp to %rsp.
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x6                 6
rbx            0x7fffffffdef8      140737488346872
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x0                 0x0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ed9            0x400ed9 <phase_2+48>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) u*0x0000000000400ee4
0x0000000000400ee4 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
=> 0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x1                 1
rbx            0x7fffffffddc0      140737488346560
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x7fffffffddd0      0x7fffffffddd0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ee4            0x400ee4 <phase_2+59>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) x/d 0x7fffffffddc0
0x7fffffffddc0:	0
(gdb) ni
0x0000000000400ee6 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
=> 0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)				//Compares the value of %eax and 0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>			//Jumps to line number 71 if two numbers is equal.
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>			//Bombs explode if two numbers are not equal.
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x1                 1						//Shows that the value of %eax is 1.
rbx            0x7fffffffddc0      140737488346560
rcx            0x0                 0
rdx            0x7fffffffddd4      140737488346580
rsi            0x0                 0
rdi            0x7fffffffd750      140737488344912
rbp            0x7fffffffddd0      0x7fffffffddd0
rsp            0x7fffffffddc0      0x7fffffffddc0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f62ac0      140737353493184
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdef0      140737488346864
r14            0x0                 0
r15            0x0                 0
rip            0x400ee6            0x400ee6 <phase_2+61>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) x/3d 0x7fffffffddc0 									//Find out the value of third input digit.
0x7fffffffddc0:	0	1	2								//2 is the third input digit by the user.
(gdb) run ans1.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y								//Run the compiler again.
Starting program: /home/lab2/Desktop/Assignment 1_2/Assignment 1/bomb001/bomb ans1.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 1 1 2 3 5							//The input number is 0 1 1 2 3 5 after tracing.

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u* 0x0000000000400f14							//The bomb does is not blown up when the compiler is executed until 0x0000000000400f14.
main (argc=<optimized out>, argv=<optimized out>) at bomb.c:83			//The bomb set at phase 2 gets diffused.
83	    phase_defused();
(gdb) 

